---
title: "Network analysis of liver expression data from female mice: finding modules related to body weight"
author: "Richard Chen"
date: "August 11, 2015"
output: 
  html_document:
    toc: true
    theme: united
---

Correlation networks are increasingly being used in bioinformatics applications. For example, weighted gene co-expression network analysis is a systems biology method for describing the correlation patterns among genes across microarray samples. Weighted correlation network analysis (WGCNA) can be used for finding clusters (modules) of highly correlated genes, for summarizing such clusters using the module eigengene or an intramodular hub gene, for relating modules to one another and to external sample traits (using eigengene network methodology), and for calculating module membership measures. Correlation networks facilitate network based gene screening methods that can be used to identify candidate biomarkers or therapeutic targets. These methods have been successfully applied in various biological contexts, e.g. cancer, mouse genetics, yeast genetics, and analysis of brain imaging data. While parts of the correlation network methodology have been described in separate publications, there is a need to provide a user-friendly, comprehensive, and consistent software implementation and an accompanying tutorial.

The WGCNA R software package is a comprehensive collection of R functions for performing various aspects of weighted correlation network analysis. The package includes functions for network construction, module detection, gene selection, calculations of topological properties, data simulation, visualization, and interfacing with external software. While the methods development was motivated by gene expression data, the underlying data mining approach can be applied to a variety of different settings.

# 0. Automatic Installation from CRAN
The WGCNA package is now available from the Comprehensive R Archive Network (CRAN), the standard repository for R add-on packages. Currently, one of the required packages is only available from Bioconductor and needs to be installed separately. To install the required packages and WGCNA, simply type
```{R, eval = FALSE}
source("http://bioconductor.org/biocLite.R") 
biocLite(c("AnnotationDbi", "impute", "GO.db", "preprocessCore", "org.Mm.eg.db")) 
install.packages("WGCNA")
```

Then, we load our dependencies.
```{R, results="hide"}
library(WGCNA)
library(ggplot2)
library(ggdendro)
options(stringsAsFactors = FALSE);
```





# 1. Data input, cleaning and pre-processing
## 1.a Loading expression data
The expression data is contained in the file LiverFemale3600.csv that comes with this tutorial. We can take a quick look at what the data looks like.
```{R}
femData = read.csv("LiverFemale3600.csv")
dim(femData); femData[1:6, 1:10]
```

In addition to expression data, the data files contain extra information about the surveyed probes we do not need. The expression data set contains 135 samples. Note that each row corresponds to a gene and each column to a sample name, expression data (F6...F7...), and auxiliary information. We now remove the auxiliary data and transpose the expression data for further analysis. Now, each row corresponds to a sample name and each column corresponds to gene.
```{R}
datExpr0 <- as.data.frame(t(femData[, -c(1:8)]));
names(datExpr0) <- femData$substanceBXH;
rownames(datExpr0) <- names(femData)[-c(1:8)];
dim(datExpr0); datExpr0[1:6, 1:10]
```



## 1.b Checking data for excessive missing values and identification of outlier microarray samples
We first check for genes and samples with too many missing values:
```{R}
gsg <- goodSamplesGenes(datExpr0, verbose = 3);
gsg$allOK
```

If the last statement returns TRUE, all genes have passed the cuts. If not, we remove the offending genes and samples
from the data:
```{R}
if (!gsg$allOK)
{
  # Optionally, print the gene and sample names that were removed:
  if (sum(!gsg$goodGenes) > 0)
    printFlush(paste("Removing genes:", paste(names(datExpr0)[!gsg$goodGenes], collapse = ", ")));
  if (sum(!gsg$goodSamples) > 0)
    printFlush(paste("Removing samples:", paste(rownames(datExpr0)[!gsg$goodSamples], collapse = ", ")));
  datExpr0 <- datExpr0[gsg$goodSamples, gsg$goodGenes] # Remove the offending genes and samples from the data:
}
```

Next we cluster the samples (in contrast to clustering genes that will come later) to see if there are any obvious outliers. There is one outlier. One can remove it by hand, or use an automatic approach. Choose a height cut that will remove the offending sample, say 15 (the red line in the plot), and use a branch cut at that height. The variable datExpr now contains the expression data ready for network analysis.
```{R, fig.width = 20, fig.height = 20}
sampleTree <- hclust(dist(datExpr0), method = "average");
plot(sampleTree, main = "Sample clustering to detect outliers")

abline(h = 15, col = "red");
clust = cutreeStatic(sampleTree, cutHeight = 15, minSize = 10)
table(clust)
# clust 1 contains the samples we want to keep.
keepSamples <- (clust==1)
datExpr <- datExpr0[keepSamples, ]
nGenes <- ncol(datExpr)
nSamples <- nrow(datExpr)
```



## 1.c Loading clinical trait data
We now read in the trait data and match the samples for which they were measured to the expression samples.
```{R}
traitData = read.csv("ClinicalTraits.csv");
dim(traitData); names(traitData)
```

Removing columns that hold information we do not need.
```{R}
allTraits <- traitData[, -c(31, 16)]
allTraits <- allTraits[, c(2, 11:36)]
dim(allTraits); names(allTraits); allTraits[1:6,1:6]
```

Finally, forming a data frame analogous to expression data that will hold the clinical traits. Here, we melted the Mice column into the rownames of our dataframe.
```{R}
femaleSamples <- rownames(datExpr)
traitRows <- match(femaleSamples, allTraits$Mice)
datTraits <- allTraits[traitRows, -1]
rownames(datTraits) <- allTraits[traitRows, 1]
datTraits[1:6,1:6]
collectGarbage()
```

We now have the expression data in the variable datExpr, and the corresponding clinical traits in the variable datTraits. Before we continue with network construction and module detection, we visualize how the clinical traits relate to the sample dendrogram.
```{R, fig.width = 20, fig.height = 20}
# Re-cluster samples
sampleTree2 = hclust(dist(datExpr), method = "average")
# Convert traits to a color representation: white means low, red means high, grey means missing entry
traitColors = numbers2colors(datTraits, signed = FALSE);
# Plot the sample dendrogram and the colors underneath.
plotDendroAndColors(sampleTree2, traitColors,
                    groupLabels = names(datTraits),
                    main = "Sample dendrogram and trait heatmap")
```

In the plot, shown in Fig. 2, white means a low value, red a high value, and grey a missing entry. The last step is to save the relevant expression and trait data for use in the next steps of the tutorial.
```{R}
save(datExpr, datTraits, file = "FemaleLiver-01-dataInput.RData")
```





# 2. Network construction and module detection
In constructing a weighted gene network, we need to choose the soft thresholding power (beta) that raises co-expression similarity, which best calculates adjacency.  This step is the bedrock of all network analyses using the WGCNA methodology. We present three different ways of constructing a network and identifying modules:

a. Using a convenient 1-step network construction and module detection function, suitable for users wishing to arrive at the result with minimum effort;

b. Step-by-step network construction and module detection for users who would like to experiment with customized/alternate
methods;

c. An automatic block-wise network construction and module detection method for users who wish to analyze data
sets too large to be analyzed all in one.

## 2.a Automatic construction of the gene network and identification of modules
### 2.a.1 Automatic network construction and module detection
Here, we automatically construct our gene network by using 'pickSoftThreshold', which aids the user in choosing a proper soft-thresholding power. The user chooses a set of candidate powers, and the function returns a set of network indices that should be inspected, for example as follows:
```{R}
# Choose a set of soft-thresholding powers = [1]  1  2  3  4  5  6  7  8  9 10 12 14 16 18 20
powers = c(c(1:10), seq(from = 12, to=20, by=2))
# Call the network topology analysis function
sft = pickSoftThreshold(datExpr, powerVector = powers, verbose = 5)
```

We can plot the Scale-free topology fit index as a function of the soft-thresholding. The red line corresponds to using an R^2 cut-off of h.
```{R, fig.width = 7, fig.height = 7}
plot(sft$fitIndices[,1], -sign(sft$fitIndices[,3])*sft$fitIndices[,2],
    xlab="Soft Threshold (power)",ylab="Scale Free Topology Model Fit,signed R^2",type="n",
    main = paste("Scale independence"));
    text(sft$fitIndices[,1], -sign(sft$fitIndices[,3])*sft$fitIndices[,2],
    labels=powers,col="red");
abline(h=0.90,col="red")
```

We can also plot Mean Connectivity as a function of the soft-thresholding power.
```{R, fig.width = 7, fig.height = 7}
plot(sft$fitIndices[,1], sft$fitIndices[,5],
    xlab="Soft Threshold (power)",ylab="Mean Connectivity", type="n",
    main = paste("Mean connectivity"))
text(sft$fitIndices[,1], sft$fitIndices[,5], labels=powers,col="red")
```


### 2.a.2 One-step network construction and module detection
We can now construct the gene network and identify modules. We chose the soft thresholding power 6 and a relatively large minimum module size of 30. A power of 6 was chosen since it is the lowest power f or which the scale-free topology fit index reaches 0.90.

The parameter mergeCutHeight is the threshold for merging of modules. We have also instructed the function to return numeric, rather than color, labels for modules, and to save the Topological Overlap Matrix. For example, net-colors contains the module assignment, and net-MEs contains the module eigengenes of the modules.
```{R}
net <- blockwiseModules(datExpr, power = 6,
                        TOMType = "unsigned", minModuleSize = 30,
                        reassignThreshold = 0, mergeCutHeight = 0.25,
                        numericLabels = TRUE, pamRespectsDendro = FALSE,
                        saveTOMs = TRUE,
                        saveTOMFileBase = "femaleMouseTOM",
                        verbose = 3)
net$MEs[1:5, 1:6]
```

We now return to the network analysis. To see how many modules were identified and what the module sizes are, one can use table(net$colors). It indicates there are 18 modules, labeled 1 through 18 in order of descending size, with sizes ranging from 609 to 34 genes. The label 0 is reserved for genes outside all modules.
```{R}
table(net$colors)
```

The hierarchical clustering dendrogram (tree) used for the module identification is returned in net$dendrograms[[1]]. The dendrogram can be displayed together with the color assignment using the following code:
```{R, fig.width = 10, fig.height = 10}
mergedColors = labels2colors(net$colors)
# Plot the dendrogram and the module colors underneath
plotDendroAndColors(net$dendrograms[[1]], mergedColors[net$blockGenes[[1]]],
                    "Module colors",
                    dendroLabels = FALSE, hang = 0.03,
                    addGuide = TRUE, guideHang = 0.05)
```

We now save the module assignment and module eigengene information necessary for subsequent analysis.
```{R}
moduleLabels = net$colors
moduleColors = labels2colors(net$colors)
MEs = net$MEs;
geneTree = net$dendrograms[[1]];
save(MEs, moduleLabels, moduleColors, geneTree,
    file = "FemaleLiver-02-networkConstruction-auto.RData")
```



## 2.b Step-by-step network construction and module detection
###2.b.1 Choosing the soft-thresholding power: analysis of network topology
This was done in 2.a.1. A power of 6 was the lowest power for which the scale-free topology fit index reached 0.90. 


### 2.b.2 Co-expression similarity and adjacency
From this, we can calculate the adjacencies.
```{R}
softPower <- 6
adjacency <- adjacency(datExpr, power = softPower)
```


### 2.b.3 Topological Overlap Matrix (TOM)
To minimize effects of noise and confounding associations, we then transformed the Adjacency Matrix into a topological overlap matrix, and calculated teh corresponding dissimilarity.
```{R}
TOM <- TOMsimilarity(adjacency)
dissTOM <- 1- TOM
```


### 2.b.4 Clustering using TOM
We now use hierarchial clustering to produce a dendrogram of genes. In the clustering tree (dendrogram), each leaf, that is a short vertical line, corresponds to a gene. Branches of the dendrogram group together densely interconnected, highly co-expressed genes.
```{R, fig.width = 10, fig.height = 10}
geneTree <- hclust(as.dist(dissTOM), method = "average");
plot(geneTree, xlab="", sub="", main = "Gene clustering on TOM-based dissimilarity", labels = FALSE, hang = 0.04);
```

There are several methods for branch cutting; our standard method is the Dynamic Tree Cut from the package dynamicTreeCut. The function returned 22 modules labeled 1-22 largest to smallest. Label 0 is reserved for unassigned genes. 
```{R}
# We like large modules, so we set the minimum module size relatively high:
minModuleSize = 30;
# Module identification using dynamic tree cut:
dynamicMods = cutreeDynamic(dendro = geneTree, distM = dissTOM,
deepSplit = 2, pamRespectsDendro = FALSE,
minClusterSize = minModuleSize);
table(dynamicMods)
```

We now plot the module assignment under the gene dendrogram:
```{R, fig.width = 10, fig.height = 10}
# Convert numeric lables into colors
dynamicColors = labels2colors(dynamicMods)
table(dynamicColors)
# Plot the dendrogram and colors underneath
sizeGrWindow(8,6)
plotDendroAndColors(geneTree, dynamicColors, "Dynamic Tree Cut",
dendroLabels = FALSE, hang = 0.03,
addGuide = TRUE, guideHang = 0.05,
main = "Gene dendrogram and module colors")
```


### 2.b.5 Merging of modules whose expression profiles are very similar
The Dynamic Tree Cut may identify modules whose expression profiles are very similar. It may be prudent to merge such modules since their genes are highly co-expressed. To quantify co-expression similarity of entire modules, we calculate their eigengenes and cluster them on their correlation. We choose a height cut of 0.25, corresponding to correlation of 0.75, to merge.
```{R}
# Calculate eigengenes
MEList = moduleEigengenes(datExpr, colors = dynamicColors)
MEs = MEList$eigengenes
# Calculate dissimilarity of module eigengenes
MEDiss = 1-cor(MEs);
# Cluster module eigengenes
METree = hclust(as.dist(MEDiss), method = "average");
# Plot the result
plot(METree, main = "Clustering of module eigengenes",
xlab = "", sub = "")

MEDissThres = 0.25
# Plot the cut line into the dendrogram
abline(h=MEDissThres, col = "red")
# Call an automatic merging function
merge = mergeCloseModules(datExpr, dynamicColors, cutHeight = MEDissThres, verbose = 3)
# The merged module colors
mergedColors = merge$colors;
# Eigengenes of the new merged modules:
mergedMEs = merge$newMEs;
```

To see what the merging did to our module colors, we plot the gene dendrogram again, with the original and merged module colors underneath.
```{R, fig.width = 10, fig.height = 10}
#pdf(file = "Plots/geneDendro-3.pdf", wi = 9, he = 6)
plotDendroAndColors(geneTree, cbind(dynamicColors, mergedColors),
c("Dynamic Tree Cut", "Merged dynamic"),
dendroLabels = FALSE, hang = 0.03,
addGuide = TRUE, guideHang = 0.05)
```

In the subsequent analysis, we will use the moduleColors, colorOrder, mnoduleLabels, and geneTree from the automatic detection method in 2.a, but using the step-by-step model is just as useful.
```{R, eval = FALSE}
# Rename to moduleColors
moduleColors = mergedColors
# Construct numerical labels corresponding to the colors
colorOrder = c("grey", standardColors(50));
moduleLabels = match(moduleColors, colorOrder)-1;
MEs = mergedMEs;
```



## 2.c Dealing with large data sets: block-wise network construction and module detection
A word of caution for the readers who would like to adapt this code for their own data. The function blockwiseModules has many parameters, and in this example most of them are left at their default value. We have attempted to provide reasonable default values, but they may not be appropriate for the particular data set reader wishes to analyze. We encourage the user to read the help file provided within the package in the R environment and experiment with tweaking the network construction and module detection parameters. The potential reward is, of course, better (biologically more relevant) results of the analysis.

A second word of caution concerning block size. In particular, the parameter maxBlockSize tells the function how large the largest block can be that the reader's computer can handle. In this example we have set the maximum block size to 2000 to illustrate the block-wise analysis and its results, but this value is needlessly small for most modern computers; the default is 5000 which is appropriate for most modern desktops. If the reader has access to a large workstation with more than 4 GB of memory, the parameter maxBlockSize can be increased. A 16GB workstation should handle up to 20000 probes; a 32GB workstation should handle perhaps 30000. A 4GB standard
desktop or a laptop may handle up to 8000-10000 probes, depending on operating system and other running programs. In general it is preferable to analyze a data set in as few blocks as possible.

### 2.c.1 Choosing the soft-thresholding power: analysis of network topology
This was done in 2.a.1. A power of 6 was the lowest power for which the scale-free topology fit index reached 0.90.


### 2.c.2 Block-wise network construction and module detection
Throughout this tutorial we work with a relatively small data set of 3600 measured probes. However, modern microarrays measure up to 50,000 probe expression levels at once. Constructing and analyzing networks with such large numbers of nodes is computationally challenging even on a large server. We now illustrate a method, implemented in the WGCNA package, that allows the user to perform a network analysis with such a large number of genes. Instead of actually using a very large data set, we will for simplicity pretend that hardware limitations restrict the number of genes that can be analyzed at once to 2000. The basic idea is to use a two-level clustering. First, we use a fast, computationally inexpensive and relatively crude clustering method to pre-cluster genes into blocks of size close to and not exceeding the maximum of 2000 genes. We then perform a full network analysis in each block separately. At the end, modules whose eigengenes are highly correlated are merged. The advantage of the block-wise approach is a
much smaller memory footprint (which is the main problem with large data sets on standard desktop computers), and a significant speed-up of the calculations. The trade-off is that due to using a simpler clustering to obtain blocks, the blocks may not be optimal, causing some outlying genes to be assigned to a different module than they would
be in a full network analysis. 
We will now pretend that even the relatively small number of genes, 3600, that we have been using here is too large, and the computer we run the analysis on is not capable of handling more than 2000 genes in one block. The automatic network construction and module detection function blockwiseModules can handle the splitting into blocks automatically; the user just needs to specify the largest number of genes that can fit in a block.

```{R}
bwnet <- blockwiseModules(datExpr, maxBlockSize = 2000,
                          power = 6, TOMType = "unsigned", minModuleSize = 30,
                          reassignThreshold = 0, mergeCutHeight = 0.25,
                          numericLabels = TRUE,
                          saveTOMs = TRUE,
                          saveTOMFileBase = "femaleMouseTOM-blockwise",
                          verbose = 3)
```

Below we will compare the results of this analysis to the results of Section 2.a in which all genes were analyzed in a single block. To make the comparison easier, we relabel the block-wise module labels so that modules with a significant overlap with single-block modules have the same label.

To see how many modules were identified and what the module sizes are, one can use table(bwLabels). Its output indicates that there are 20 modules, labeled 1 through 20, The label 0 is reserved for genes outside of all modules. The hierarchical clustering dendrograms (trees) used for the module identification for each block are returned in bwnet-dendrograms[[1]], bwnet-dendrograms[[2]].
```{R}
load(file = "FemaleLiver-02-networkConstruction-auto.RData");
# Relabel blockwise modules
bwLabels = matchLabels(bwnet$colors, moduleLabels);
# Convert labels to colors for plotting
bwModuleColors = labels2colors(bwLabels)
table(bwLabels)
```

Plotting the dendrogram and the module colors underneath for block 1
```{R, fig.width = 10, fig.height = 10}
plotDendroAndColors(bwnet$dendrograms[[1]], bwModuleColors[bwnet$blockGenes[[1]]],
"Module colors", main = "Gene dendrogram and module colors in block 1",
dendroLabels = FALSE, hang = 0.03,
addGuide = TRUE, guideHang = 0.05)
```

Plotting the dendrogram and the module colors underneath for block 2
```{R, fig.width = 10, fig.height = 10}
plotDendroAndColors(bwnet$dendrograms[[2]], bwModuleColors[bwnet$blockGenes[[2]]],
"Module colors", main = "Gene dendrogram and module colors in block 2",
dendroLabels = FALSE, hang = 0.03,
addGuide = TRUE, guideHang = 0.05)
```


### 2.c.3 Comparing the single block and block-wise network analysis
We now compare the results of the block-wise analysis with 2 blocks to the results Section 2.a in which all genes were analyzed in a single block. A simple visual check can be obtained by plotting the single-block dendrogram with the single-block and block-wise module colors underneath the dendrogram. Visual inspection confirms that there is excellent agreement between thesingle-block and the block-wise module assignment.
```{R}
plotDendroAndColors(geneTree,
cbind(moduleColors, bwModuleColors),
c("Single block", "2 blocks"),
main = "Single block gene dendrogram and module colors",
dendroLabels = FALSE, hang = 0.03,
addGuide = TRUE, guideHang = 0.05)
```

We now verify that module eigengenes of modules that correspond to one another in the single-block and block-wise approaches are extremely similar. We first calculate the module eigengenes based on the single block and block-wise module colors.
```{R}
singleBlockMEs = moduleEigengenes(datExpr, moduleColors)$eigengenes;
blockwiseMEs = moduleEigengenes(datExpr, bwModuleColors)$eigengenes;
```

Next we match the single-block and block-wise eigengenes by name and calculate the correlations of the corresponding eigengenes. Each number above represents the correlation of a single-block eigengene with its corresponding block-wise counterpart. The correlations are all very close to 1 (the turquoise eigengene changed orientation), again indicating that the block-wise and single-block analyses lead to very similar results.
```{R}
single2blockwise = match(names(singleBlockMEs), names(blockwiseMEs))
signif(diag(cor(blockwiseMEs[, single2blockwise], singleBlockMEs)), 3)
```





# 3. Relating modules to external information and identifying important genes
## 3.a Quantifying module-trait associations
In this analysis we would like to identify modules that are significantly associated with the measured clinical traits. Since we already have a summary profile (eigengene) for each module, we simply correlate eigengenes with external traits and look for the most significant associations:
```{R}
# Define numbers of genes and samples
nGenes = ncol(datExpr);
nSamples = nrow(datExpr);
# Recalculate MEs with color labels
MEs0 = moduleEigengenes(datExpr, moduleColors)$eigengenes
MEs = orderMEs(MEs0)
moduleTraitCor = cor(MEs, datTraits, use = "p");
moduleTraitPvalue = corPvalueStudent(moduleTraitCor, nSamples);
```

Since we have a moderately large number of modules and traits, a suitable graphical representation will help in reading the table. We color code each association by the correlation value:
```{R}
# Will display correlations and their p-values
textMatrix <- paste(signif(moduleTraitCor, 2), "\n(",
                    signif(moduleTraitPvalue, 1), ")", sep = "");
                    dim(textMatrix) = dim(moduleTraitCor)
                    par(mar = c(6, 8.5, 3, 3));
```

We can display the correlation values within a heatmap plot
```{R, fig.width = 15, fig.height = 15}
labeledHeatmap(Matrix = moduleTraitCor,
              xLabels = names(datTraits),
              yLabels = names(MEs),
              ySymbols = names(MEs),
              colorLabels = FALSE,
              colors = greenWhiteRed(50),
              textMatrix = textMatrix,
              setStdMargins = FALSE,
              cex.text = 0.5,
              zlim = c(-1,1),
              main = paste("Module-trait relationships"))
```


## 3.b Gene relationship to trait and important modules: Gene Significance and Module Membership
We quantify associations of individual genes with our trait of interest (weight) by defining Gene Significance GS as (the absolute value of) the correlation between the gene and the trait. For each module, we also define a quantitative measure of module membership MM as the correlation of the module eigengene and the gene expression profile. This allows us to quantify the similarity of all genes on the array to every module. Each row corresponds to a module eigengene, column to a trait. Each cell contains the corresponding correlation and p-value. The table is color-coded by correlation according to the color legend.
```{R}
# Define variable weight containing the weight column of datTrait
weight = as.data.frame(datTraits$weight_g);
names(weight) = "weight"
# names (colors) of the modules
modNames = substring(names(MEs), 3)
geneModuleMembership = as.data.frame(cor(datExpr, MEs, use = "p"));
MMPvalue = as.data.frame(corPvalueStudent(as.matrix(geneModuleMembership), nSamples));

names(geneModuleMembership) = paste("MM", modNames, sep="");
names(MMPvalue) = paste("p.MM", modNames, sep="");
geneTraitSignificance = as.data.frame(cor(datExpr, weight, use = "p"));
GSPvalue = as.data.frame(corPvalueStudent(as.matrix(geneTraitSignificance), nSamples));
names(geneTraitSignificance) = paste("GS.", names(weight), sep="");
names(GSPvalue) = paste("p.GS.", names(weight), sep="");

```


## 3.c Intramodular analysis: identifying genes with high GS and MM
Using the GS and MM measures, we can identify genes that have a high significance for weight as well as high module membership in interesting modules. As an example, we look at the brown module that has the highest association with weight. We plot a scatterplot of Gene Significance vs. Module Membership in the brown module. 
Clearly, GS and MM are highly correlated, illustrating that genes highly significantly associated with a trait are often also the most important (central) elements of modules associated with the trait.
```{R, fig.width = 10, fig.height = 10}
module = "brown"
column = match(module, modNames);
moduleGenes <- moduleColors == module;
verboseScatterplot(abs(geneModuleMembership[moduleGenes, column]),
                   abs(geneTraitSignificance[moduleGenes, 1]),
                   xlab = paste("Module Membership in", module, "module"),
                   ylab = "Gene significance for body weight",
                   main = paste("Module membership vs. gene significance\n"),
                   cex.main = 1.2, cex.lab = 1.2, cex.axis = 1.2, col = module)
```



## 3.d Summary output of network analysis results
We have found modules with high association with our trait of interest, and have identified their central players by the Module Membership measure. We now merge this statistical information with gene annotation and write out a file that summarizes the most important results and can be inspected in standard spreadsheet software such as MSExcel or Open Office Calc.
Our expression data are only annotated by probe ID names. names(datExpr) will return all probe Ids included in the analysis.
```{R}
head(names(datExpr))
```

To facilitate interpretation of the results, we use a probe annotation file provided by the manufacturer of the expression arrays to connect probe IDs to gene names and universally recognized identification numbers (Entrez codes).
```{R}
annot = read.csv(file = "GeneAnnotation.csv");
dim(annot)
names(annot)
probes = names(datExpr)
probes2annot = match(probes, annot$substanceBXH)
# The following is the number or probes without annotation:
sum(is.na(probes2annot))
# Should return 0.
```

We now create a data frame holding the following information for all probes: probe ID, gene symbol, Locus Link ID (Entrez code), module color, gene significance for weight, and module membership and p-values in all modules. The  modules will be ordered by their significance for weight, with the most significant ones to the left.
```{R}
# Create the starting data frame
geneInfo0 = data.frame(substanceBXH = probes,
                      geneSymbol = annot$gene_symbol[probes2annot],
                      LocusLinkID = annot$LocusLinkID[probes2annot],
                      moduleColor = moduleColors,
                      geneTraitSignificance,
                      GSPvalue)

# Order modules by their significance for weight
modOrder = order(-abs(cor(MEs, weight, use = "p")))

# Add module membership information in the chosen order
for (mod in 1:ncol(geneModuleMembership))
{
  oldNames = names(geneInfo0)
  geneInfo0 = data.frame(geneInfo0, geneModuleMembership[, modOrder[mod]],
                        MMPvalue[, modOrder[mod]]);
  names(geneInfo0) = c(oldNames, paste("MM.", modNames[modOrder[mod]], sep=""),
                      paste("p.MM.", modNames[modOrder[mod]], sep=""))
}

# Order the genes in the geneInfo variable first by module color, then by geneTraitSignificance
geneOrder = order(geneInfo0$moduleColor, -abs(geneInfo0$GS.weight));
geneInfo = geneInfo0[geneOrder, ]
```

This data frame can be written into a text-format spreadsheet. The reader is encouraged to open and view the file in a spreadsheet software, or inspect it directly within R using
the command fix(geneInfo).
```{R}
write.csv(geneInfo, file = "geneInfo.csv")
```






# 4 Interfacing network analysis with other data such as functional annotation and gene ontology
Our previous analysis has identified several modules (labeled brown, red, and salmon) that are highly associated with weight. To facilitate a biological interpretation, we would like to know the gene ontologies of the genes in the modules, whether they are significantly enriched in certain functional categories etc.


## 4.a Output gene lists for use with online software and services
One option is to simply export a list of gene identifiers that can be used as input for several popular gene ontology and functional enrichment analysis suites such as David or AmiGO. For example, we write out the LocusLinkID (entrez) codes for the brown module into a file.
```{R}
# Read in the probe annotation
annot = read.csv(file = "GeneAnnotation.csv");
# Match probes in the data set to the probe IDs in the annotation file
probes = names(datExpr)
probes2annot = match(probes, annot$substanceBXH)
# Get the corresponding Locuis Link IDs
allLLIDs = annot$LocusLinkID[probes2annot];
# $ Choose interesting modules
intModules = c("brown", "red", "salmon")
for (module in intModules)
{
# Select module probes
modGenes = (moduleColors==module)
# Get their entrez ID codes
modLLIDs = allLLIDs[modGenes];
# Write them into a file
fileName = paste("LocusLinkIDs-", module, ".txt", sep="");
write.table(as.data.frame(modLLIDs), file = fileName,
row.names = FALSE, col.names = FALSE)
}
# As background in the enrichment analysis, we will use all probes in the analysis.
fileName = paste("LocusLinkIDs-all.txt", sep="");
write.table(as.data.frame(allLLIDs), file = fileName,
row.names = FALSE, col.names = FALSE)
```


## 4.b Enrichment analysis directly within 
The WGCNA package now contains a function to perform GO enrichment analysis using a simple, single step. To run the function, Biconductor packages GO.db, AnnotationDBI, and the appropriate organism-specific annotation package(s) need to be installed before running this code. The organism-specific packages have names of the form org.Xx.eg.db, where Xx stands for organism code, for example, Mm for mouse, Hs for human, etc. The only exception
is yeast, for which no org.Xx.eg.db package is available; instead, the package carries the name org.Sc.sgd.db. Please visit the Bioconductor main page at http://www.bioconductor.org to download and install the required packages. In our case we are studying gene expressions from mice, so this code needs the package org.Mm.eg.db. Calling the GO enrichment analysis function GOenrichmentAnalysis is very simple. The function takes a vector of module labels,
and the Entrez (a.k.a. Locus Link) codes for the genes whose labels are given
```{R, eval = FALSE}
GOenr = GOenrichmentAnalysis(moduleColors, allLLIDs, organism = "mouse", nBestP = 10);
```

This is an enrichment table containing the 10 best terms for each module present in moduleColors.
```{R, eval = FALSE}
tab = GOenr$bestPTerms[[4]]$enrichment
names(tab)
```

We refer the reader to the help page of the function within R (available using ?GOenrichmentAnalysis at the R prompt) for details of what each column means. Because the term definitions can be quite long, the table is a bit difficult to on the screen. For readers who prefer to look at tables in Excel or similar spreadsheet software, it is best to save the table into a file and open it using their favorite tool.
```{R, eval = FALSE}
write.table(tab, file = "GOEnrichmentTable.csv", sep = ",", quote = TRUE, row.names = FALSE)
```

On the other hand, to quickly take a look at the results, one can also abridge the table a bit and display it directly on screen.
```{R, eval = FALSE}
keepCols = c(1, 2, 5, 6, 7, 12, 13);
screenTab = tab[, keepCols];
# Round the numeric columns to 2 decimal places:
numCols = c(3, 4);
screenTab[, numCols] = signif(apply(screenTab[, numCols], 2, as.numeric), 2)
# Truncate the the term name to at most 40 characters
screenTab[, 7] = substring(screenTab[, 7], 1, 40)
# Shorten the column names:
colnames(screenTab) = c("module", "size", "p-val", "Bonf", "nInTerm", "ont", "term name");
rownames(screenTab) = NULL;
# Set the width of R's output. The reader should play with this number to obtain satisfactory output.
options(width=95)
# Finally, display the enrichment table:
screenTab
```





# 5 Visualization of networks within R
## 5.a Visualizing the gene network
One way to visualize a weighted network is to plot its heatmap. Each row and column of the heatmap correspond to a single gene. The heatmap can depict adjacencies or topological overlaps, with light colors denoting low adjacency (overlap) and darker colors higher adjacency (overlap). In addition, the gene dendrograms and module colors are plotted along the top and left side of the heatmap.
```{R, fig.width = 20, fig.height = 20}
# Calculate topological overlap anew: this could be done more efficiently by saving the TOM
# calculated during module detection, but let us do it again here.
dissTOM = 1-TOMsimilarityFromExpr(datExpr, power = 6);
# Transform dissTOM with a power to make moderately strong connections more visible in the heatmap
plotTOM = dissTOM^7;
# Set diagonal to NA for a nicer plot
diag(plotTOM) = NA;
# Call the plot function
TOMplot(plotTOM, geneTree, moduleColors, main = "Network heatmap plot, all genes")
```

Note that the generating the heatmap plot may take a substantial amount of time. It is possible to restrict the number of genes to speed up the plotting; however, the gene dendrogram of a subset of genes will often look different from the gene dendrogram of all genes. In the following example we restrict the number of plotted genes to 400.
```{R, fig.width = 20, fig.height = 20}
nSelect = 400
# For reproducibility, we set the random seed
set.seed(10);
select = sample(nGenes, size = nSelect);
selectTOM = dissTOM[select, select];
# There's no simple way of restricting a clustering tree to a subset of genes, so we must re-cluster.
selectTree = hclust(as.dist(selectTOM), method = "average")
selectColors = moduleColors[select];
# Open a graphical window
# Taking the dissimilarity to a power, say 10, makes the plot more informative by effectively changing
# the color palette; setting the diagonal to NA also improves the clarity of the plot
plotDiss = selectTOM^7;
diag(plotDiss) = NA;
TOMplot(plotDiss, selectTree, selectColors, main = "Network heatmap plot, selected genes")
```


## 5.b Visualizing the network of eigengenes
It is often interesting to study the relationships among the found modules. One can use the eigengenes as representative profiles and quantify module similarity by eigengene correlation. The package contains a convenient function plotEigengeneNetworks that generates a summary plot of the eigengene network. It is usually informative to add a clinical trait (or multiple traits) to the eigengenes to see how the traits fit into the eigengene network.
The heatmap depicts the Topological Overlap Matrix (TOM) among all genes in the analysis. Light color represents low overlap and progressively darker red color represents higher overlap. Blocks of darker colors along the diagonal are the modules. The gene dendrogram and
module assignment are also shown along the left side and the top
```{R, fig.width = 20, fig.height = 20}
# Recalculate module eigengenes
MEs = moduleEigengenes(datExpr, moduleColors)$eigengenes
# Isolate weight from the clinical traits
weight = as.data.frame(datTraits$weight_g);
names(weight) = "weight"
# Add the weight to existing module eigengenes
MET = orderMEs(cbind(MEs, weight))
plotEigengeneNetworks(MET, "", marDendro = c(0,4,1,2), marHeatmap = c(3,4,1,2), cex.lab = 0.8, xLabelsAngle = 90)
```

The function produces a dendrogram of the eigengenes and trait(s), and a heatmap of their relationships. To split the dendrogram and heatmap plots, we can use the following code. 
The eigengene dendrogram and heatmap identify groups of correlated eigengenes termed meta-modules. For example, the dendrogram indicates that red, brown and bluw modules are
highly related; their mutual correlations are stronger than their correlations with weight. On the other hand, the salmon module, which is also significantly correlated with weight, is not part of the same meta-module as the red, brown and blue modules, at least if meta-modules are defined as tight custers of modules (for example, modules with a correlation of eigengenes of at least 0.5). 
```{R, fig.width = 10, fig.height = 10}
plotEigengeneNetworks(MET, "Eigengene dendrogram", marDendro = c(0,4,2,0),
plotHeatmaps = FALSE)

plotEigengeneNetworks(MET, "Eigengene adjacency heatmap", marHeatmap = c(3,4,2,2),
plotDendrograms = FALSE, xLabelsAngle = 90)
```





# 6. Exporting a gene network to external visualization software
## 6.a Exporting to VisANT
```{R}
# Recalculate topological overlap
TOM = TOMsimilarityFromExpr(datExpr, power = 6);
# Read in the annotation file
annot = read.csv(file = "GeneAnnotation.csv");
# Select module
module = "brown";
# Select module probes
probes = names(datExpr)
inModule = (moduleColors==module);
modProbes = probes[inModule];
# Select the corresponding Topological Overlap
modTOM = TOM[inModule, inModule];
dimnames(modTOM) = list(modProbes, modProbes)
# Export the network into an edge list file VisANT can read
vis = exportNetworkToVisANT(modTOM,
file = paste("VisANTInput-", module, ".txt", sep=""),
weighted = TRUE,
threshold = 0,
probeToGene = data.frame(annot$substanceBXH, annot$gene_symbol) )
```

Because the brown module is rather large, we can restrict the genes in the output to say the 30 top hub genes in the module.
```{R}
nTop = 30;
IMConn = softConnectivity(datExpr[, modProbes]);
top = (rank(-IMConn) <= nTop)
vis = exportNetworkToVisANT(modTOM[top, top],
file = paste("VisANTInput-", module, "-top30.txt", sep=""),
weighted = TRUE,
threshold = 0,
probeToGene = data.frame(annot$substanceBXH, annot$gene_symbol) )
```

## 6.b Exporting to Cytoscape
Cytoscape allows the user to input an edge file and a node file, allowing the user to specify for example the link weights and the node colors. Here we demonstrate the output of two modules, the red and brown ones, to Cytoscape. Note that network input to Cytoscape is a bit more involved and the user should take care to select all necessary options for the edge and node files to be interpreted correctly. We refer the reader to Cytoscape documentation for all the necessary details.
```{R}
# Recalculate topological overlap if needed
TOM = TOMsimilarityFromExpr(datExpr, power = 6);
# Read in the annotation file
annot = read.csv(file = "GeneAnnotation.csv");
# Select modules
modules = c("brown", "red");
# Select module probes
probes = names(datExpr)
inModule = is.finite(match(moduleColors, modules));
modProbes = probes[inModule];
modGenes = annot$gene_symbol[match(modProbes, annot$substanceBXH)];
# Select the corresponding Topological Overlap
modTOM = TOM[inModule, inModule];

dimnames(modTOM) = list(modProbes, modProbes)
# Export the network into edge and node list files Cytoscape can read
cyt = exportNetworkToCytoscape(modTOM,
edgeFile = paste("CytoscapeInput-edges-", paste(modules, collapse="-"), ".txt", sep=""),
nodeFile = paste("CytoscapeInput-nodes-", paste(modules, collapse="-"), ".txt", sep=""),
weighted = TRUE,
threshold = 0.02,
nodeNames = modProbes,
altNodeNames = modGenes,
nodeAttr = moduleColors[inModule]);
```