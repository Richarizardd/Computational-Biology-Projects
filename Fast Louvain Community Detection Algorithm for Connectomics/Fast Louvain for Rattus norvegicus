{
 "cells": [
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "collapsed": true
   },
   "outputs": [],
   "source": [
    "# Dependencies\n",
    "import networkx as nx\n",
    "import matplotlib.pyplot as plt\n",
    "from itertools import permutations\n",
    "from itertools import combinations\n",
    "from collections import defaultdict"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "collapsed": true
   },
   "outputs": [],
   "source": [
    "# Initialization\n",
    "G1 = nx.read_graphml(\"rattus.norvegicus_brain_1.graphml\")\n",
    "G2 = nx.read_graphml(\"rattus.norvegicus_brain_2.graphml\")\n",
    "G3 = nx.read_graphml(\"rattus.norvegicus_brain_3.graphml\")"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "collapsed": true
   },
   "outputs": [],
   "source": [
    "class Louvain(object):\n",
    "    def __init__(self):\n",
    "        self.MIN_VALUE = 0.0000001\n",
    "        self.node_weights = {}\n",
    "    \n",
    "    @classmethod\n",
    "    def convertIGraphToNxGraph(cls, igraph):\n",
    "        node_names = igraph.vs[\"name\"]\n",
    "        edge_list = igraph.get_edgelist()\n",
    "        weight_list = igraph.es[\"weight\"]\n",
    "        node_dict = defaultdict(str)\n",
    "\n",
    "        for idx, node in enumerate(igraph.vs):\n",
    "            node_dict[node.index] = node_names[idx]\n",
    "\n",
    "        convert_list = []\n",
    "        for idx in range(len(edge_list)):\n",
    "            edge = edge_list[idx]\n",
    "            new_edge = (node_dict[edge[0]], node_dict[edge[1]], weight_list[idx])\n",
    "            convert_list.append(new_edge)\n",
    "\n",
    "        convert_graph = nx.Graph()\n",
    "        convert_graph.add_weighted_edges_from(convert_list)\n",
    "        return convert_graph\n",
    "\n",
    "    def updateNodeWeights(self, edge_weights):\n",
    "        node_weights = defaultdict(float)\n",
    "        for node in edge_weights.keys():\n",
    "            node_weights[node] = sum([weight for weight in edge_weights[node].values()])\n",
    "        return node_weights\n",
    "\n",
    "    def getBestPartition(self, graph, param=1.):\n",
    "        node2com, edge_weights = self._setNode2Com(graph)\n",
    "\n",
    "        node2com = self._runFirstPhase(node2com, edge_weights, param)\n",
    "        best_modularity = self.computeModularity(node2com, edge_weights, param)\n",
    "\n",
    "        partition = node2com.copy()\n",
    "        new_node2com, new_edge_weights = self._runSecondPhase(node2com, edge_weights)\n",
    "\n",
    "        while True:\n",
    "            new_node2com = self._runFirstPhase(new_node2com, new_edge_weights, param)\n",
    "            modularity = self.computeModularity(new_node2com, new_edge_weights, param)\n",
    "            if abs(best_modularity - modularity) < self.MIN_VALUE:\n",
    "                break\n",
    "            best_modularity = modularity\n",
    "            partition = self._updatePartition(new_node2com, partition)\n",
    "            _new_node2com, _new_edge_weights = self._runSecondPhase(new_node2com, new_edge_weights)\n",
    "            new_node2com = _new_node2com\n",
    "            new_edge_weights = _new_edge_weights\n",
    "        return partition\n",
    "\n",
    "    def computeModularity(self, node2com, edge_weights, param):\n",
    "        q = 0\n",
    "        all_edge_weights = sum([weight for start in edge_weights.keys() for end, weight in edge_weights[start].items()]) / 2\n",
    "\n",
    "        com2node = defaultdict(list)\n",
    "        for node, com_id in node2com.items():\n",
    "            com2node[com_id].append(node)\n",
    "\n",
    "        for com_id, nodes in com2node.items():\n",
    "            node_combinations = list(combinations(nodes, 2)) + [(node, node) for node in nodes]\n",
    "            cluster_weight = sum([edge_weights[node_pair[0]][node_pair[1]] for node_pair in node_combinations])\n",
    "            tot = self.getDegreeOfCluster(nodes, node2com, edge_weights)\n",
    "            q += (cluster_weight / (2 * all_edge_weights)) - param * ((tot / (2 * all_edge_weights)) ** 2)\n",
    "        return q\n",
    "\n",
    "    def getDegreeOfCluster(self, nodes, node2com, edge_weights):\n",
    "        weight = sum([sum(list(edge_weights[n].values())) for n in nodes])\n",
    "        return weight\n",
    "\n",
    "    def _updatePartition(self, new_node2com, partition):\n",
    "        reverse_partition = defaultdict(list)\n",
    "        for node, com_id in partition.items():\n",
    "            reverse_partition[com_id].append(node)\n",
    "\n",
    "        for old_com_id, new_com_id in new_node2com.items():\n",
    "            for old_com in reverse_partition[old_com_id]:\n",
    "                partition[old_com] = new_com_id\n",
    "        return partition\n",
    "\n",
    "    def _runFirstPhase(self, node2com, edge_weights, param):\n",
    "        all_edge_weights = sum([weight for start in edge_weights.keys() for end, weight in edge_weights[start].items()]) / 2\n",
    "        self.node_weights = self.updateNodeWeights(edge_weights)\n",
    "        status = True\n",
    "        while status:\n",
    "            statuses = []\n",
    "            for node in node2com.keys():\n",
    "                statuses = []\n",
    "                com_id = node2com[node]\n",
    "                neigh_nodes = [edge[0] for edge in self.getNeighborNodes(node, edge_weights)]\n",
    "\n",
    "                max_delta = 0.\n",
    "                max_com_id = com_id\n",
    "                communities = {}\n",
    "                for neigh_node in neigh_nodes:\n",
    "                    node2com_copy = node2com.copy()\n",
    "                    if node2com_copy[neigh_node] in communities:\n",
    "                        continue\n",
    "                    communities[node2com_copy[neigh_node]] = 1\n",
    "                    node2com_copy[node] = node2com_copy[neigh_node]\n",
    "\n",
    "                    delta_q = 2 * self.getNodeWeightInCluster(node, node2com_copy, edge_weights) - (self.getTotWeight(node, node2com_copy, edge_weights) * self.node_weights[node] / all_edge_weights) * param\n",
    "                    if delta_q > max_delta:\n",
    "                        max_delta = delta_q\n",
    "                        max_com_id = node2com_copy[neigh_node]\n",
    "\n",
    "                node2com[node] = max_com_id\n",
    "                statuses.append(com_id != max_com_id)\n",
    "\n",
    "            if sum(statuses) == 0:\n",
    "                break\n",
    "\n",
    "        return node2com\n",
    "\n",
    "    def _runSecondPhase(self, node2com, edge_weights):\n",
    "        com2node = defaultdict(list)\n",
    "\n",
    "        new_node2com = {}\n",
    "        new_edge_weights = defaultdict(lambda : defaultdict(float))\n",
    "\n",
    "        for node, com_id in node2com.items():\n",
    "            com2node[com_id].append(node)\n",
    "            if com_id not in new_node2com:\n",
    "                new_node2com[com_id] = com_id\n",
    "\n",
    "        nodes = list(node2com.keys())\n",
    "        node_pairs = list(permutations(nodes, 2)) + [(node, node) for node in nodes]\n",
    "        for edge in node_pairs:\n",
    "            new_edge_weights[new_node2com[node2com[edge[0]]]][new_node2com[node2com[edge[1]]]] += edge_weights[edge[0]][edge[1]]\n",
    "        return new_node2com, new_edge_weights\n",
    "\n",
    "    def getTotWeight(self, node, node2com, edge_weights):\n",
    "        nodes = [n for n, com_id in node2com.items() if com_id == node2com[node] and node != n]\n",
    "\n",
    "        weight = 0.\n",
    "        for n in nodes:\n",
    "            weight += sum(list(edge_weights[n].values()))\n",
    "        return weight\n",
    "\n",
    "    def getNeighborNodes(self, node, edge_weights):\n",
    "        if node not in edge_weights:\n",
    "            return 0\n",
    "        return edge_weights[node].items()\n",
    "\n",
    "    def getNodeWeightInCluster(self, node, node2com, edge_weights):\n",
    "        neigh_nodes = self.getNeighborNodes(node, edge_weights)\n",
    "        node_com = node2com[node]\n",
    "        weights = 0.\n",
    "        for neigh_node in neigh_nodes:\n",
    "            if node_com == node2com[neigh_node[0]]:\n",
    "                weights += neigh_node[1]\n",
    "        return weights\n",
    "    \n",
    "    def _setNode2Com(self, graph):\n",
    "        node2com = {}\n",
    "        edge_weights = defaultdict(lambda : defaultdict(float))\n",
    "        for idx, node in enumerate(graph.nodes()):\n",
    "            node2com[node] = idx\n",
    "            for edge in graph[node].items():\n",
    "                edge_weights[node][edge[0]] = edge[1]['weight']\n",
    "        return node2com, edge_weights"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "collapsed": false
   },
   "outputs": [],
   "source": [
    "#first compute the best partition\n",
    "ratLouvain1 = Louvain()\n",
    "ratLouvain2 = Louvain()\n",
    "ratLouvain3 = Louvain()\n",
    "\n",
    "ratPartition1 = ratLouvain1.getBestPartition(G)\n",
    "ratPartition2 = ratLouvain2.getBestPartition(G)\n",
    "ratPartition3 = ratLouvain3.getBestPartition(G)"
   ]
  },
  {
   "cell_type": "raw",
   "metadata": {},
   "source": [
    "print ratPartition1"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "collapsed": true
   },
   "outputs": [],
   "source": []
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 2",
   "language": "python",
   "name": "python2"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 2
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython2",
   "version": "2.7.11"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 0
}
